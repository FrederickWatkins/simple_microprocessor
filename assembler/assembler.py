# Generated by google gemini on 31/01/2026
import argparse
import sys
import re
import os

class CustomAssembler:
    def __init__(self):
        self.symbol_table = {}
        self.registers = {"r0": 0, "r1": 1, "r2": 2, "r3": 3}
        self.opcodes = {
            "nop": 0, "call": 1, "jmp": 2, "jmpz": 3,
            "lw": 4, "sw": 5, "jmpnz": 6, "move": 7,
            "add": 8, "sub": 9, "rr": 10, "rl": 11,
            "mul": 12, "div": 13, "rem": 14,
        }
        self.MEM_SIZE = 256  # 8-bit addressing space

    def clean_line(self, line):
        line = re.sub(r'#.*|;.*', '', line)
        return line.replace(',', ' ').strip()

    def process_sections(self, lines):
        text_lines, data_lines = [], []
        current_section = ".text"
        text_addr, data_addr = 0, 0

        for line in lines:
            cleaned = self.clean_line(line)
            if not cleaned: continue
            
            if cleaned.lower() == ".data":
                current_section = ".data"
                continue
            elif cleaned.lower() == ".text":
                current_section = ".text"
                continue

            if ":" in cleaned:
                label, rest = cleaned.split(":", 1)
                self.symbol_table[label.strip()] = data_addr if current_section == ".data" else text_addr
                cleaned = rest.strip()
                if not cleaned: continue

            if current_section == ".data":
                if data_addr >= self.MEM_SIZE:
                    raise MemoryError("Data segment exceeds 8-bit address space (256 words).")
                data_lines.append(cleaned)
                data_addr += 1
            else:
                if text_addr >= self.MEM_SIZE:
                    raise MemoryError("Text segment exceeds 8-bit address space (256 words).")
                text_lines.append(cleaned)
                text_addr += 1
        
        return text_lines, data_lines

    def parse_operand(self, token):
        if token.lower() in self.registers:
            return "reg", self.registers[token.lower()]
        elif token in self.symbol_table:
            return "imm", self.symbol_table[token]
        else:
            try:
                return "imm", int(token, 0)
            except ValueError:
                raise ValueError(f"Undefined symbol or invalid literal: {token}")

    def encode_instruction(self, line):
        tokens = line.split()
        mnemonic = tokens[0].lower()
        opcode = self.opcodes[mnemonic]
        rs, rd, imm = 0, 0, 0
        args = tokens[1:]

        if mnemonic == "nop":
            pass
        elif mnemonic in ["jmp", "jmpne"]:
            type_rs, val_rs = self.parse_operand(args[0])
            if type_rs == "reg": rs = val_rs
            else: rs, imm = 0, val_rs
        else:
            if len(args) >= 1:
                type_rs, val_rs = self.parse_operand(args[0])
                if type_rs == "reg": rs = val_rs
                else: rs, imm = 0, val_rs
            if len(args) >= 2:
                _, rd = self.parse_operand(args[1])
            if len(args) >= 3:
                _, imm = self.parse_operand(args[2])

        binary = ((imm & 0xFF) << 8) | ((rd & 0x3) << 6) | ((rs & 0x3) << 4) | (opcode & 0xF)
        return format(binary, '04x')

    def assemble(self, input_file, output_text, output_data):
        with open(input_file, 'r') as f:
            lines = f.readlines()

        text_lines, data_lines = self.process_sections(lines)
        
        # Generate HEX lists
        text_hex = [self.encode_instruction(l) for l in text_lines]
        data_hex = [format(int(l, 0) & 0xFF, '04x') for l in data_lines]

        # Padding logic: fill remaining space with 0000
        text_hex += ["0000"] * (self.MEM_SIZE - len(text_hex))
        data_hex += ["00"] * (self.MEM_SIZE - len(data_hex))

        # Write out files
        for filename, content in [(output_text, text_hex), (output_data, data_hex)]:
            with open(filename, 'w') as f:
                # Group by 8 for better readability in the file
                for i in range(0, len(content)):
                    f.write(content[i] + "\n")
            print(f"Generated: {filename} (256 words)")

def main():
    parser = argparse.ArgumentParser(description="Padded 16-bit ISA Assembler")
    parser.add_argument("-i", "--input", help="Source .asm file")
    parser.add_argument("-o", "--output", default="program.hex", help="Code output file")
    parser.add_argument("-d", "--data", help="Data output file")
    
    args = parser.parse_args()
    if not args.data:
        base, ext = os.path.splitext(args.output)
        args.data = f"{base}_data{ext}"

    asm = CustomAssembler()
    try:
        asm.assemble(args.input, args.output, args.data)
    except Exception as e:
        print(f"Assembly Error: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()